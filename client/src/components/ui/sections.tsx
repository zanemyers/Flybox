// import React, { useEffect, useRef, useState } from "react";
import React from "react";
import ReactMarkdown, { type Components } from "react-markdown";

import TableOfContents, { type Props as TocProps } from "../ui/tableOfContents";
import Image, { type ImageProps } from "./images";

interface AboutSectionProps extends ImageProps {
  heading: string;
  children: React.ReactNode;
  reverse?: boolean; // defaults to false
}

export function AboutSection({
  heading,
  children,
  reverse = false,
  ...imageProps
}: AboutSectionProps) {
  return (
    <section
      className={`row align-items-center ${reverse ? "flex-md-row-reverse" : ""}`}
    >
      <div className="col-md-6">
        <Image variant="attributed" {...imageProps} />
      </div>
      <div className="col-md-6">
        <h2 className="h4 mb-3">{heading}</h2>
        {children}
      </div>
    </section>
  );
}

interface DocSectionProps {
  subSection?: boolean;
  title: string;
  p1?: string; // the fist p tag (description or overview)
  p2?: string; // the final p tag (conclusion)
  children: React.ReactNode;
}

export function DocSection(props: DocSectionProps) {
  const id = props.title.toLowerCase().replace(/ /g, "-");
  const HeaderTag = props.subSection ? "h5" : "h3";
  const p1Component: Components | null = props.subSection
    ? { p: "span" }
    : null;

  return (
    <section id={id} className="mb-2">
      <HeaderTag className="pt-2">{props.title}</HeaderTag>
      {props.p1 && (
        <ReactMarkdown components={p1Component}>{props.p1}</ReactMarkdown>
      )}
      {props.children}
      {props.p2 && <ReactMarkdown>{props.p2}</ReactMarkdown>}
    </section>
  );
}

interface DocOverviewProps extends TocProps {
  title: string;
  icon?: string;
  children: React.ReactNode; // the intro paragraph(s)
}

export function DocOverview(props: DocOverviewProps) {
  return (
    <>
      <h1>
        {props.icon} {props.title} Documentation
      </h1>
      {props.children}

      <hr />

      {/* Table of contents */}
      <TableOfContents items={props.items} />
    </>
  );
}

interface InstructionStep {
  icon: string;
  text: string;
}

interface InstructionPanelProps {
  app: string;
  description: string;
  steps: InstructionStep[];
  defaultsDescription?: string;
}

const stepComponent: Components = {
  p: ({ node, ...props }) => <span {...props} />, // inline text instead of <p>
};

export function InstructionPanel(props: InstructionPanelProps) {
  return (
    <div className="p-4 bg-light border rounded flex-fill d-flex flex-column">
      {/* What the tool does */}
      <h2 className="h4 mb-2">üõ†Ô∏è What This Tool Does</h2>
      <ReactMarkdown>{props.description}</ReactMarkdown>

      {/* Steps */}
      <h3 className="h5 mb-2">üìã How to Use It</h3>
      <div className="steps">
        {props.steps.map((step, i) => {
          return (
            <div key={i}>
              <span className="icon">{step.icon}</span>
              <ReactMarkdown components={stepComponent}>
                {step.text}
              </ReactMarkdown>
            </div>
          );
        })}
        <p className="mt-2 small text-muted">
          For more detailed instructions, see the{" "}
          <a href={`/docs?tab=${props.app}`}>{props.app} documentation</a>.
        </p>
      </div>

      {/* Defaults */}
      {props.defaultsDescription && (
        <>
          <h3 className="h5 mb-2">‚ÑπÔ∏è About the Defaults</h3>
          <ReactMarkdown>{props.defaultsDescription}</ReactMarkdown>
        </>
      )}

      {/* Privacy */}
      <p className="text-muted small mb-0">
        üîí <strong>Privacy Notice:</strong> Your inputs are never stored. Only
        the output files generated by this tool are retained temporarily to
        facilitate downloads.
      </p>
    </div>
  );
}
//
// interface FileData {
//   name: string;
//   buffer?: string;
//   url?: string; // blob URL we generate
// }
//
// interface ProgressPanelProps {
//   route: string;
//   jobId: string;
// }
//
// type Status = "IN_PROGRESS" | "COMPLETED" | "CANCELLED" | "FAILED";
//
// export function ProgressPanel(props: ProgressPanelProps) {
//   const [status, setStatus] = useState<Status>("IN_PROGRESS");
//   const [files, setFiles] = useState<FileData[]>([]);
//   const progressAreaRef = useRef<HTMLPreElement>(null);
//
//   // Load saved file names on first render
//   useEffect(() => {
//     const saved = localStorage.getItem(`${props.route}-files`);
//     if (saved) {
//       try {
//         setFileNames(new Set(JSON.parse(saved)));
//       } catch {
//         setFileNames(new Set());
//       }
//     }
//   }, [props.route]);
//
//   // Keep localStorage in sync with fileNames
//   useEffect(() => {
//     localStorage.setItem(
//       `${props.route}-files`,
//       JSON.stringify([...fileNames]),
//     );
//   }, [fileNames, props.route]);
//
//   // Poll server for progress updates
//   useEffect(() => {
//     let intervalId: NodeJS.Timeout;
//
//     async function pollProgress() {
//       if (status === "COMPLETED") return;
//
//       const res = await fetch(`/api/${props.route}/${props.jobId}/updates`);
//       const data = await res.json();
//
//       // Update progress messages
//       if (progressAreaRef.current) {
//         progressAreaRef.current.textContent = data.message;
//       }
//
//       // Update status
//       setStatus(data.status);
//
//       // Handle new files
//       downloadFile(data.files);
//     }
//
//     intervalId = setInterval(pollProgress, 1000);
//
//     return () => clearInterval(intervalId);
//   }, [props.route, props.jobId, status, files]);
//
//   // When adding new files, check fileNames to prevent duplicates
//   const downloadFile = (newFiles: FileData[]) => {
//     newFiles.forEach((file) => {
//       // Check if we already have a file with this name
//       const exists = files.some((f) => f.name === file.name);
//       if (!exists || !file.url) {
//         const file: FileData = {
//           ...file,
//           url: file.url ?? getFileUrl(file.buffer!),
//         };
//
//         setFiles((prev) => [...prev, normalizedFile]);
//
//         // Auto-download once
//         const link = document.createElement("a");
//         link.href = normalizedFile.url;
//         link.download = file.name;
//         link.click();
//       }
//     });
//   };
//
//   const handleCancel = async () => {
//     await fetch(`/api/${props.route}/${props.jobId}/cancel`, {
//       method: "POST",
//     });
//     cleanLocalStorage();
//   };
//
//   const cleanLocalStorage = () => {
//     localStorage.removeItem(`${props.route}-files`);
//     localStorage.removeItem(`${props.route}-jobId`);
//     setFiles([]);
//   };
//
//   const getFileUrl = (buffer: string) => {
//     const blob = new Blob([
//       Uint8Array.from(atob(buffer), (c) => c.charCodeAt(0)),
//     ]);
//     return URL.createObjectURL(blob);
//   };
//
//   return (
//     <div className="p-4 border rounded bg-white shadow-sm flex-fill d-flex flex-column">
//       <div className="mb-3">
//         <h5 className="mb-2">
//           {status === "IN_PROGRESS" ? "üîÑ Running Search..." : "‚úÖ Completed"}
//         </h5>
//         <pre
//           ref={progressAreaRef}
//           className="small text-monospace"
//           style={{ whiteSpace: "pre-wrap" }}
//         />
//       </div>
//
//       <div id="fileLinks" className="mt-auto mb-3">
//         {files.map(({ name, url }: FileData) => (
//           <a
//             key={name}
//             href={url}
//             download={name}
//             className="d-block mb-2 small"
//           >
//             {name}
//           </a>
//         ))}
//       </div>
//
//       <button
//         onClick={status === "IN_PROGRESS" ? handleCancel : cleanLocalStorage}
//         className={`w-100 btn ${status === "IN_PROGRESS" ? "btn-danger" : "btn-secondary"}`}
//       >
//         {status === "IN_PROGRESS" ? "Cancel" : "Close"}
//       </button>
//     </div>
//   );
// }
